#     Memcache原理分析篇

###   Memcache工作原理

    工作原理包括存和读两部分：
    
    存：Client端通过指定的server端的ip地址进行访问，需要缓存的对象或者数据以key-value的形式保存在server端。key通过hash，
    
    根据hash值吧value放到对应的server上。
    
    读：当需要获取对象数据时，先对key进行hash，通过获得的值可以确定他被保存在哪台server上，然后再向该server发出请求。
    
    也就是说Client端，只需要知道保存hash（key）的值在哪台服务器上就可以了
    
    Memcache通过在内存里维护一个统一的巨大的hash表
    
###   Memcache特性
    
    * 1.最大30天的数据过期时间,设置为永久的也会在这个时间过期
    * 2.最大键长为250字节，大于该长度无法存储，常量KEY_MAX_LENGTH 250控制
    * 3.单个item最大数据是1MB，超过1MB数据不予存储，常量POWER_BLOCK 1048576进行控制
    * 4.最大同时连接数是200(与tomcat一致)，通过conn_init()的freetotal进行控制，最大软连接数是1024，即settings.maxconns=1024
###   删除过期item

    Memcache为每个item设置过期时间，但不是到期就把item从内存删除，而是访问item时，如果到了有效期，才把item内存中删除。

    惰性删除：
        
        延迟删除到期的item到查找进行，可以提高memcache的效率。这样不必每时每刻检查到期的item，从而提高CPU的工作效率。
  
 ### LRU算法淘汰数据
 
    当Memcached使用内存大于设置的最大内存使用时，为了腾出内存空间来存放新的数据项，Memcached会启动LRU算法淘汰旧的数据项。
    
    淘汰规则是，从数据项列表尾部开始遍历，在列表中查找一个引用计数器为0的item，把此item释放掉。
  
    为什么要从item列表尾部开始遍历呢？ 因为memcached会把刚刚访问过的item放到item列表头部，所以尾部的item都是没有或很少访

    问的，这就是LRU算法的精髓。
    
    果在item列表找不到计数器为0的item，就查找一个3小时没有访问过的item。把他释放，如果还是找不到，就返回NULL（申请内存失败）。

###  Memcache线上常见问题之缓存雪崩

    一般是由于某个节点失效，导致其它节点的缓存命中率下降，缓存中缺失的数据直接去数据库查询，短时间内造成数据库服务器崩溃。
    
    或者是由于缓存周期性失效，比如设置每隔6个小时失效一次，那么每6个小时将会有一个请求峰值，严重的话，也会导致数据库崩溃
    
    重启DB后，短期内又被压垮，但缓存又会恢复一点，DB反复重启多次，直至缓存重建完毕，才能恢复稳定。
    
    如果小网站，平时访问量不大的情况下，数据缓存的时间不同，失效时间也不同，可能不会出现此问题。而对于一些访问量较大的网站，
    
    可能memcache一开起，瞬间几万次，甚至几千万次的同时访问，短期内就会缓存完所有的，也就会导致近似同时失效，出现上述这种后果。
    
    解决方案：
    
    * 缓存有效期随机设置3-9小时之间的一个随机值
    * 控制缓存在闲时过期（比如夜里）。


###  Memcache线上常见问题之永久数据被踢现象

    在实际使用中，常常有人发现，自己设置的永久数据，莫名其妙的丢失了。
    
    其实，这要从两个方面来考虑：
    
    * memcache的惰性删除机制
    * LRU算法淘汰机制
    
    通俗理解：
    * 数据在内存中失效后，并不会立马被删除，只有在下次get时候，系统才会将其删除
    * Memcache可以因此，被一些未被及时删除的数据占满空间
    * 加之LRU淘汰机制，永久数据如果很少被访问的话，在内存空间被占满的情况下，再有新数据被缓存，则永久数据，就有可能被删除
    
    解决方案：
    永久数据和非永久数据分开放。

###  Memcache线上常见问题之缓存无底洞现象
###  Memcache分布式算法

    memcached的分布式是依靠客户端的算法来实现，假设键名为$key，服务器数量为N，常规的实现方式有两种：
    
    * 取模哈希 
    
    crc32($key)%N，通过这个算法将键名映射到某一台服务器，比如需要存取一个键名为myname的缓存，服务器数量为3，那么通过算法计算：
    
    crc32('myname')%3=0，那么这个缓存就落到第1台服务器上面
    
    这种方式虽然简单可行，但是增减服务器的时候，缓存将面临大量的重建，比如上面的例子中，新增了1台服务器，服务器数量变为4台，通过
    
    算法计算：crc32('myname')%4=3，从第1台变成第3台了，导致缓存重建；又比如第1台服务器挂了，缓存的存取都会失败，导致短时间内大量
    
    的请求涌入mysql
 
    * 一致性哈希 
    
    一致性哈希就是为了解决上面的缓存重建而设计的，取模法不理想的原因就是算法的本质就是根据服务器数量来计算的，缓存跟服务器是一一对应，
    
    要想灵活一点就不能是一对一的关系，一致性哈希算法首先创建出一个首（ 0 ）尾（ 2^32-1 ）相接的环形的哈希空间，如下图的圆环，然后把服
    
    务器通过hash算法映射到环形的某一点，如下图中node1、node2、node3、node4，然后再把缓存的键映射到环形的某一点，获取某个键的内容是从
    
    这个键的节点按顺时针方向开始查找服务器节点，找到的第一台服务器就是这个缓存要进行存取的服务器，如此一来当node1服务器挂了，影响到的只
    
    是从node3到node1节点之间的缓存数据，这些数据将会去node2中存取，这样可以把缓存重建的代价降低
    
    注：详细见https://www.cnblogs.com/justlikeheaven/p/7761027.html博文
    
    
    
    
    
   
