### TCP协议

* tcp协议的生命周期

![](https://github.com/Yangliangfeng/PHP/raw/master/Images/tcp_life_time.png)

* tcp连接常见的问题
```
Operation now in progress问题:

1. 丢包，错误IP

2. blacklog满了 && Linux的内核参数设置为：tcp_abort_on_overflow = 0
    1）backlog队列：服务端在收到客户端发我的ACK包的时候，会把链接放入backlog队列中。
    
       比如swoole_server会从blacklog队列中取走链接，才会调用onConnect这个回调函数。
       
       由于服务端的死循环，导致不能够正常取走建立的连接，backlog队列满了之后，服务端就
       
       会随机丢弃第一个syn包，让客户端连接超时或者重新链接服务端。
 
 3. backlog的长度：min(maxconn, backlog) 决定backlog的实际长度
 
 4. ss -lt  查看backlog队列的长度
 
 5. 设置tcp_abort_on_overflow内核参数
 
    echo  '1' > /proc/sys/net/ipv4/tcp_abort_on_overflow = 1
    
    当backlog队列满了之后，会报：Error： Connection reset by peer
```
* SYN Flood攻击
```
syn queue队列
  
  1. 客户端短期内发送大量的syn，服务端会把客户端接受到的syn包放入syn queue队列中。
  
     syn_queue对列的长度由：tcp_max_syn_backlog决定
     
  2. tcp_synack_retries 重试的次数，就是客户端没有给服务端发送ack确认包
  
  3. tcp_syncookies 默认开启；原理：不是每个syn过来，服务端就给其分配资源
  
     而是绑定一个cookie,等到第三次握手cookie验证通过，才会分配资源。
```
